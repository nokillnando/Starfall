--@name GT2Hud1.6 (Final Network Fix - Refactored by Gemini)
--@author redfox (original), Manus (optimization & rewrite), Gemini (refactor)
--@shared

-- =========================================================
--  SERVER (Robust Rate-Limited Logic)
-- =========================================================
if SERVER then
    wire.adjustInputs({
        "Chassis", "EngineRPM", "GearboxGear", "Throttle", "Brake", "Clutch", "TurboPSI", "GearMode"
    }, {
        "Entity", "Number", "Number", "Number", "Number", "Number", "Number", "Number"
    })
    
    local engineMaxRpm = 7000
    local TurboPsiMax = 6
    
    local activePlayers = {}
    local lastSentState = {
        rpm = -999, speed = -999, gear = -999, throttle = -999,
        brake = -999, clutch = -999, turbopsi = -999, gearmode = -999
    }
    local currentState = {}
    local stateChanged = false

    -- This hook now only watches for state changes and sets a flag.
    -- It no longer sends network messages directly.
    hook.add("Think", "GT2Hud_StateWatcher", function()
        if table.isEmpty(activePlayers) then return end

        local chassis = wire.ports.Chassis
        
        currentState = {
            rpm = wire.ports.EngineRPM or 0,
            speed = (chassis and chassis:isValid()) and chassis:getVelocity():getLength() or 0,
            gear = wire.ports.GearboxGear or 0,
            throttle = wire.ports.Throttle or 0,
            brake = wire.ports.Brake or 0,
            clutch = wire.ports.Clutch or 0,
            turbopsi = wire.ports.TurboPSI or 0,
            gearmode = wire.ports.GearMode or 0
        }

        if math.floor(currentState.rpm / 10) ~= math.floor(lastSentState.rpm / 10) or
           math.floor(currentState.speed) ~= math.floor(lastSentState.speed) or
           currentState.gear ~= lastSentState.gear or
           math.floor(currentState.throttle * 100) ~= math.floor(lastSentState.throttle * 100) or
           math.floor(currentState.brake * 100) ~= math.floor(lastSentState.brake * 100) or
           math.floor(currentState.clutch * 100) ~= math.floor(lastSentState.clutch * 100) or
           math.floor(currentState.turbopsi) ~= math.floor(lastSentState.turbopsi) or
           currentState.gearmode ~= lastSentState.gearmode then
            
            stateChanged = true
        end
    end)

    -- This new timer sends the state to clients at a controlled rate (max 20Hz)
    -- but only if the state has actually changed.
    timer.create("GT2Hud_NetworkSender", 0.05, 0, function()
        if table.isEmpty(activePlayers) or not stateChanged then return end

        -- Prune invalid players
        for ply in pairs(activePlayers) do
            if not ply:isValid() then
                activePlayers[ply] = nil
            end
        end
        
        local playersToSend = table.getKeys(activePlayers)
        if #playersToSend == 0 then return end

        net.start("hud_sendState")
        net.writeFloat(currentState.rpm)
        net.writeFloat(engineMaxRpm)
        net.writeFloat(currentState.speed)
        net.writeFloat(currentState.throttle)
        net.writeFloat(currentState.brake)
        net.writeFloat(currentState.clutch)
        net.writeFloat(currentState.turbopsi)
        net.writeFloat(TurboPsiMax)
        net.writeInt(currentState.gear, 4)
        net.writeInt(currentState.gearmode, 4)
        net.send(playersToSend)

        lastSentState = currentState
        stateChanged = false
    end)

    net.receive("hud_start", function(len, ply)
        activePlayers[ply] = true
        -- Force an update for the new player
        stateChanged = true 
    end)

    net.receive("hud_stop", function(len, ply)
        activePlayers[ply] = nil
    end)

    hook.add("PlayerDisconnected", "GT2Hud_PlayerCleanup", function(ply)
        activePlayers[ply] = nil
    end)
end

-- =========================================================
--  CLIENT (Structure from 1.3 to fix scale issue)
-- =========================================================
if CLIENT then
    ----- Adjustable values -----
    local AutoMode = false 
    local MultipleReverseGears = false
    local enableInterpolation = true

    --[[
        CUSTOMIZATION: Choose what to draw.
        Available elements: "rpm", "kph", "mph", "gear", "input", "turbopsi"
    ]]
    local drawOrder = {"rpm", "kph", "gear", "input"}
    
    -- Colors
    local bgColor = Color(0,0,0,80)
    local textColor = Color(255,236,12,200)
    local whiteColor = Color(255, 255, 255, 255)
    local redColor = Color(255, 0, 0, 255)
    local unactiveColor = Color(0,0,0,160)
    local clutchColor = Color(100,100,255,255)
    local brakeColor = Color(255,100,100,255)
    local throttleColor = Color(100,255,100,255)
    
    ----- Internal Vars -----
    local s_smoothrpm = 0
    local s_smoothturbo = 0
    
    local data = {
        time = timer.systime(), rpm = 0, rpmMax = 7000, speed = 0, gear = 0,
        throttle = 0, brake = 0, clutch = 0, turbopsi = 0, maxturbopsi = 25,
        gearmode = 0
    }
    local prevdata = table.copy(data)
    
    local units = { ["kph"] = 3600 * 0.0000254, ["mph"] = 3600 / 63360 }
    local speedLabels = { ["kph"] = "K P H", ["mph"] = "M P H" }
    
    local cos, sin, rad, clamp, round, floor, abs = math.cos, math.sin, math.rad, math.clamp, math.round, math.floor, math.abs
    
    function unitsTo(u, t) return (u * 0.75) * (units[t] or 0) end
    
    local fonts = {}
    local materials = {
        smallticks = material.create("UnlitGeneric"),
        bigticks = material.create("UnlitGeneric"),
    }
    materials.smallticks:setTexture("$basetexture", "vgui/white")
    materials.bigticks:setTexture("$basetexture", "vgui/white")

    local W, H, scale = 0, 0, 1

    function setupHUD()
        W, H = render.getGameResolution()
        if not H or H == 0 then H = 1080 end -- Failsafe
        scale = H / 1080
        
        fonts = {
            text = render.createFont("Roboto Mono", floor(25 * scale), 500, true),
            speed = render.createFont("HalfLife2", floor(70 * scale), 800, true),
            gear = render.createFont("Roboto Mono", floor(60 * scale), 1000, true),
            rpmNum = render.createFont("HalfLife2", floor(35 * scale), 500, true),
            turboNum = render.createFont("Roboto Mono", floor(15 * scale), 500, true),
        }
    end
    
    net.receive("hud_sendState", function()
        prevdata = table.copy(data)
        data.time = timer.systime()
        data.rpm = net.readFloat()
        data.rpmMax = net.readFloat()
        data.speed = net.readFloat()
        data.throttle = net.readFloat()
        data.brake = net.readFloat()
        data.clutch = net.readFloat()
        data.turbopsi = net.readFloat()
        data.maxturbopsi = net.readFloat()
        data.gear = net.readInt(4)
        data.gearmode = net.readInt(4)
    end)
    
    function drawRPMBox(pos, radius, rpm, rpmMax)
        if not rpmMax or rpmMax <= 0 then return end
        
        s_smoothrpm = clamp(s_smoothrpm + (rpm - s_smoothrpm) * 0.15, 0, rpmMax)
        local powerbandend = rpmMax * 0.8
        
        render.setColor(bgColor)
        render.drawFilledCircle(pos.x, pos.y, radius)
        render.setColor(Color(55, 55, 55, 200))
        render.drawFilledCircle(pos.x, pos.y, radius * 0.2)
        
        for i = 0, rpmMax, 250 do
            local anglestep = (255 / rpmMax) * i
            local is_big_tick = (i % 1000 == 0 and i > 0)
            
            local in_powerband = i >= powerbandend
            local col_on = in_powerband and redColor or whiteColor
            local col_off = in_powerband and Color(170, 0, 0, 150) or Color(200, 200, 200, 150)
            
            local current_color = (s_smoothrpm >= i) and col_on or col_off
            
            local cos_a, sin_a = cos(rad(105 + anglestep)), sin(rad(105 + anglestep))
            
            if is_big_tick then
                render.setColor(current_color)
                render.setMaterial(materials.bigticks)
                render.drawTexturedRectRotated(pos.x + cos_a * radius * 0.9, pos.y + sin_a * radius * 0.9, radius * 0.18, radius * 0.02, anglestep - 75)
                
                render.setFont(fonts.rpmNum)
                render.setColor(current_color)
                render.drawSimpleText(pos.x + cos_a * radius * 0.7, pos.y + sin_a * radius * 0.7, tostring(i / 1000), 1, 1)
            elseif i > 0 then
                render.setColor(current_color)
                render.setMaterial(materials.smallticks)
                render.drawTexturedRectRotated(pos.x + cos_a * radius * 0.95, pos.y + sin_a * radius * 0.95, radius * 0.09, radius * 0.01, anglestep - 75)
            end
        end
        
        local endang = 105 + round((s_smoothrpm/rpmMax) * 255, 0)
        local c_ang, s_ang = cos(rad(endang)), sin(rad(endang))
        local in_red = s_smoothrpm >= powerbandend
        render.setColor(in_red and redColor or Color(175,0,0,255))
        render.setMaterial(materials.smallticks)
        render.drawTexturedRectRotated(pos.x + c_ang * radius * 0.5, pos.y + s_ang * radius * 0.5, radius, radius * 0.02, endang)
    end

    function drawTurboBox(pos, radius, turbopsi, maxturbopsi)
        if not maxturbopsi or maxturbopsi <= 0 then return end

        s_smoothturbo = clamp(s_smoothturbo + (turbopsi - s_smoothturbo) * 0.15, 0, maxturbopsi)
        local powerbandend = maxturbopsi * 0.8

        render.setColor(bgColor)
        render.drawFilledCircle(pos.x, pos.y, radius)
        render.setColor(Color(55, 55, 55, 200))
        render.drawFilledCircle(pos.x, pos.y, radius * 0.2)

        local tick_step = maxturbopsi / 10 
        for i = 0, maxturbopsi, tick_step do
            if i == 0 then continue end
            local anglestep = (255 / maxturbopsi) * i
            local is_big_tick = (i % (tick_step * 2) < tick_step) 

            local in_powerband = i >= powerbandend
            local col_on = in_powerband and redColor or whiteColor
            local col_off = in_powerband and Color(170, 0, 0, 150) or Color(200, 200, 200, 150)
            local current_color = (s_smoothturbo >= i) and col_on or col_off

            local cos_a, sin_a = cos(rad(105 + anglestep)), sin(rad(105 + anglestep))
            
            render.setColor(current_color)
            if is_big_tick then
                render.setMaterial(materials.bigticks)
                render.drawTexturedRectRotated(pos.x + cos_a * radius * 0.9, pos.y + sin_a * radius * 0.9, radius * 0.18, radius * 0.02, anglestep - 75)
                render.setFont(fonts.turboNum)
                render.drawSimpleText(pos.x + cos_a * radius * 0.7, pos.y + sin_a * radius * 0.7, tostring(round(i)), 1, 1)
            else
                render.setMaterial(materials.smallticks)
                render.drawTexturedRectRotated(pos.x + cos_a * radius * 0.95, pos.y + sin_a * radius * 0.95, radius * 0.09, radius * 0.01, anglestep - 75)
            end
        end

        local endang = 105 + round((s_smoothturbo/maxturbopsi) * 255, 0)
        local c_ang, s_ang = cos(rad(endang)), sin(rad(endang))
        local in_red = s_smoothturbo >= powerbandend
        render.setColor(in_red and redColor or Color(175,0,0,255))
        render.setMaterial(materials.smallticks)
        render.drawTexturedRectRotated(pos.x + c_ang * radius * 0.5, pos.y + s_ang * radius * 0.5, radius, radius * 0.02, endang)
    end

    function drawGearBox(pos, gear, gearmode, scale)
        local size = Vector(60 * scale, 60 * scale)
        render.setColor(bgColor)
        render.drawRoundedBox(8 * scale, pos.x - size.x/2, pos.y - size.y/2, size.x, size.y)

        render.setFont(fonts.gear)
        render.setColor(textColor)
        
        local gearText = ""
        if AutoMode then
            if gearmode == 0 then gearText = "P"
            elseif gearmode == 1 then gearText = MultipleReverseGears and gear < 0 and "R" .. tostring(abs(gear)) or "R"
            elseif gearmode == 2 then gearText = "N"
            elseif gearmode == 3 then local currentGear = (gear > 0) and tostring(gear) or ""; gearText = "D" .. currentGear
            else gearText = tostring(gearmode - 3) end
        else
            if gear == 0 then gearText = "N"
            elseif gear < 0 then gearText = MultipleReverseGears and "R" .. tostring(abs(gear)) or "R"
            else gearText = tostring(gear) end
        end
        
        render.drawSimpleText(pos.x, pos.y, gearText, 1, 1)
    end

    function drawSpeedBox(pos, speed, units_key, scale)
        local size = Vector(140 * scale, 60 * scale)
        render.setColor(bgColor)
        render.drawRoundedBox(8 * scale, pos.x - size.x/2, pos.y - size.y/2, size.x, size.y)

        render.setFont(fonts.speed)
        render.setColor(textColor)
        render.drawSimpleText(pos.x, pos.y - (5 * scale), string.format("%03d", clamp(unitsTo(speed, units_key), 0, 999)), 1, 1)
        
        render.setFont(fonts.text)
        render.setColor(textColor)
        render.drawSimpleText(pos.x, pos.y + (40 * scale), speedLabels[units_key], 1, 1)
    end
    
    function drawInputBox(pos, throttle, brake, clutch, scale)
        local size = Vector(120 * scale, 120 * scale)
        local boxpos = pos - size/2
        local linesize = Vector(22 * scale, 88 * scale)
        
        local throttleNorm = clamp(throttle, 0, 1)    
        local brakeNorm = clamp(brake, 0, 1) 
        local clutchNorm = clamp(clutch, 0, 1)
        
        render.setColor(bgColor)
        render.drawRoundedBox(16 * scale, boxpos.x, boxpos.y, size.x, size.y)

        render.setColor(unactiveColor)
        render.drawRect(boxpos.x + 16 * scale, boxpos.y + 16 * scale, linesize.x, linesize.y)
        render.drawRect(boxpos.x + 49 * scale, boxpos.y + 16 * scale, linesize.x, linesize.y)
        render.drawRect(boxpos.x + 82 * scale, boxpos.y + 16 * scale, linesize.x, linesize.y)
        
        render.setColor(clutchColor)
        render.drawRect(boxpos.x + 16 * scale, boxpos.y + 16 * scale + linesize.y * (1 - clutchNorm), linesize.x, linesize.y * clutchNorm)
        render.setColor(brakeColor)
        render.drawRect(boxpos.x + 49 * scale, boxpos.y + 16 * scale + linesize.y * (1 - brakeNorm), linesize.x, linesize.y * brakeNorm)
        render.setColor(throttleColor)
        render.drawRect(boxpos.x + 82 * scale, boxpos.y + 16 * scale + linesize.y * (1 - throttleNorm), linesize.x, linesize.y * throttleNorm)
    end
    
    function interpolatedData(prevdata, data)
        local intdata = {}
        local curtime = timer.systime()
        local interval = data.time - prevdata.time
        if interval <= 0 then return data end
        local interpolation = clamp((curtime - data.time)/interval, 0, 1)
        for k,v in pairs(data) do
            if type(v) == "number" and type(prevdata[k]) == "number" and v ~= prevdata[k] then
                intdata[k] = prevdata[k] + (v - prevdata[k]) * interpolation
            else
                intdata[k] = v
            end
        end
        return intdata 
    end
    
    function drawHUD()
        -- If fonts are not created, set them up. This also calculates scale.
        if not fonts.speed then 
            setupHUD() 
            -- If setup fails, fonts.speed will still be nil, so we return to avoid errors.
            if not fonts.speed then return end
        end

        local main_radius = 180 * scale
        local rpm_pos = Vector(W - main_radius - 30 * scale, H - main_radius - 30 * scale)
        
        local positions = {
            rpm = rpm_pos,
            speed = rpm_pos + Vector(-main_radius * -0.1, main_radius * 0.6),
            gear = rpm_pos + Vector(main_radius * 0.45, main_radius * 0.2),
            input = Vector(W/2, H - 70 * scale),
            turbo = rpm_pos - Vector(main_radius * 1.7, -80),
        }
        
        local d = enableInterpolation and interpolatedData(prevdata, data) or data
        
        for _, name in ipairs(drawOrder) do
            if name == "rpm" then 
                drawRPMBox(positions.rpm, main_radius, d.rpm, data.rpmMax)            
            elseif name == "gear" then 
                drawGearBox(positions.gear, data.gear, data.gearmode, scale)
            elseif name == "kph" or name == "mph" then 
                drawSpeedBox(positions.speed, d.speed, name, scale)
            elseif name == "input" then
                drawInputBox(positions.input, d.throttle, d.brake, d.clutch, scale)
            elseif name == "turbopsi" then
                drawTurboBox(positions.turbo, main_radius * 0.6, d.turbopsi, data.maxturbopsi)
            end
        end
    end
    
    hook.add("hudconnected", "hud_Activate", function()
        setupHUD()
        net.start("hud_start")
        net.send()
        hook.add("drawhud", "hud_DrawHUD", drawHUD)
    end)
    
    hook.add("huddisconnected", "hud_Deactivate", function()
        net.start("hud_stop")
        net.send()
        hook.remove("drawhud", "hud_DrawHUD")
    end)
end